## Method 1 = clock

imagin a clock:\
? a clock 12 nums
```
a-> 7-1=6
b-> 13-1=12
c-> 6*12=72

encryption: y = x^5
decryption: x = y^29
```
? clock gears up!\
72=12??? in positition are the same!

this is the prime number encryption decryption

example pseudo
- p & q random prime numbers generated in custom hour --> exam: alice clock by 13, bob clock by 17
- - a=p^13
- - b=q^17
- - A=b^13 && B=a^17 == same number
```
a = alice p^primeNumX
b = bob q^primeNumY
a send to bob <--> b send to alice
A = alice b^primeNumX
B = bob a^primeNumX
A === B
```
this equition safe by e^N mod n

---

## Method 2 = secreties!
hash(a) generating by hash(b), and can decipher hash(b) by using revert function from hash(a)

#### problem
```
___________________
|hash(a) | hash(b)|
___________________
    ^         |
    |    ____________
    |<---| xor hash |
	 ____________

___________________________________
decrypt: hash(a) -> xor -> hash(b)
___________________________________
```

#### solution (key = random prime number, two side accepted that)
```
___________________
|hash(a) | hash(b)|
___________________
    ^         |
    |     |+ key |
    |    ____________
    |<---| xor hash |
	 ____________

___________________________________________
decrypt: hash(a) -> xor -> - key -> hash(b)
___________________________________________
```
hash(b) like private key, hash(a) like a message or public key

usecase: "ratchet message encryption"

for more informatio, using this in "diffie hellman". in messaging purposes on not-blockchain applications just remember to "sync" and "deleting" message from the device. (look like End2End encryption)

---

## Method 3 = zk-proof of whisper statement?
problem: how to accept "n"
```
____________________________________________________
n = random prime number, accept by two sides
alice = a	->	proof = g*(a|b) % n
bob = b		->	proof = g*(a|b) % n
____________________________________________________
```
answer: using "ratchet - hash(a)" solution and in/on hashed conversation.
- n = random number
- g = generator area (where code publicly run, and "n" somewhere in the edge of this area)
- "n" position into "g" is LFSR driven (random initial state, unlimited chance to generate random by hirarchical shifting to the right and replace to the left by using xor pattern)
- LFSR presentation code in the end of this document
```
________________________________
| n1        | n3               |
________________________________
|       n4      |   n2         |
________________________________
```
this conversation/convensition not like [SchrÃ¶dinger's cat](https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat) , and answer is O(1)=1 try.

---

### I found this two good examples for LFSR around the web

#### LFSR presentation
```py
state = 0b1001
for i in range(15):
	print("{:04b}".format(state))
	newbit = (state ^ (state >> 1)) & 1
	state = (state >> 1) | (newbit << 3)
```

#### huge amount of random number
```py
##state = 0b1001
state =  (1 << 127) | 1
while true:
	print(state & 1, end = ' ')
	newbit = (state ^ (state >> 1) ^ (state >> 2) ^ (state >> 7)) & 1
	state = (state >> 1) | (newbit << 127)

## this code made random number. by the power of my cpu  maybe 39billion years for finish randoms !!!
## this LFSR python codes generated by @Computerphile, to present LFSR
```
For safe generating the random number by a hardware, you can use "Atari" transistor. so cheap and useful. problem is: each second just 1 random number processing!

---

## Method 4 = RSA-129
R=rivest - S=shamir - A=Adleman ==> RSA build in 1977. basement of zk-proof in 2019to2023(now is 2023).\
to old algorithm and useless on blockchain industry, but popular, because noob(non-creative) engineers have big products!!!

#### My proof:
**bank problem**: you have big number as N (certificated you as an owner), you lock the N and the key owner is the bank (as T)\
so your secure from fraud and scams, but the key owner not you!\
everyone can have your N, but just bank can open that.\
**owner property in blockchain**: for proofing the owner is you, need to know the nighbers proving you. in blockchain the key (T) is your private key. now why need proving you by the nighbers?\
answer is the anonymously transaction.\
but this type of solution is like a : **A donkey who is burdened with books and claims knowledge**

#### psuedo code:
random prime number x times to random prime number y = unique number to generate public key as z\
the true calculation is the length. so we use big numbers like 40 digits
```
x = primeGeneratorRandom(48 digit)
y = primeGeneratorRandom(52 digit)
// r is rsa
r = x * y
// z is encrypted rsa
z = hash(r)
```
security details: rsa made by prime numbers lentgh must be 2^2048 to not cracking in this decade (2020 to 2030)\
each 4 years we have X2 power for solving equetions!

### Example private and public key generator by using "RSA"
note: 
- first run `npm install` then copy code in below in `index.js`, then run this code by `node index.js`
- after finish, four files generating in the same folder, 
- - hash: `privateHash.pem` & `publicHash.pem` "dont use in final project"
- - rsa: `privateRsa.pem` & `publicRsa.pem`
```node
const crypto = require("crypto");
const fs = require("fs");
const keccak256 = require("keccak256"); 

const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
  // The standard secure default length for RSA keys is 2048 bits
  modulusLength: 2048,
});

// public key generator
const exportedPublicKeyBuffer = publicKey.export({
  type: "pkcs1",
  format: "pem",
});

// private key generator
const exportedPrivateKeyBuffer = privateKey.export({
  type: "pkcs1",
  format: "pem",
});
// *********************************************************************
function run(){
	const pubHash = keccak256(exportedPublicKeyBuffer).toString("hex");
	const privHash = keccak256(exportedPrivateKeyBuffer).toString("hex");
	fs.writeFileSync("publicHash.pem", "0x"+pubHash, { encoding: "utf-8" });
	fs.writeFileSync("privateHash.pem", "0x"+privHash, { encoding: "utf-8" });
	const pubRsa = exportedPublicKeyBuffer.toString("hex");
	const privRsa = exportedPrivateKeyBuffer.toString("hex");
	fs.writeFileSync("publicRsa.pem", pubRsa, { encoding: "utf-8" });
	fs.writeFileSync("privateRsa.pem", privRsa, { encoding: "utf-8" });
}
run();
```

---

#### Problem of sensetive data solved by using erlang
#erlang for sensetive transaction have the better performance...
