## Method 1 = clock

imagin a clock:\
? a clock 12 nums
```
a-> 7-1=6
b-> 13-1=12
c-> 6*12=72

encryption: y = x^5
decryption: x = y^29
```
? clock gears up!\
72=12??? in positition are the same!

this is the prime number encryption decryption

---

## Method 2 = secreties!
hash(a) generating by hash(b), and can decipher hash(b) by using revert function from hash(a)

#### problem
```
___________________
|hash(a) | hash(b)|
___________________
    ^         |
    |    ____________
    |<---| xor hash |
	 ____________

___________________________________
decrypt: hash(a) -> xor -> hash(b)
___________________________________
```

#### solution (key = random prime number, two side accepted that)
```
___________________
|hash(a) | hash(b)|
___________________
    ^         |
    |     |+ key |
    |    ____________
    |<---| xor hash |
	 ____________

___________________________________________
decrypt: hash(a) -> xor -> - key -> hash(b)
___________________________________________
```
hash(b) like private key, hash(a) like a message or public key

usecase: "ratchet message encryption"

for more informatio, using this in "diffie hellman". in messaging purposes on not-blockchain applications just remember to "sync" and "deleting" message from the device. (look like End2End encryption)

---

## Method 3 = zk-proof of whisper statement?
problem: how to accept "n"
```
____________________________________________________
n = random prime number, accept by two sides
alice = a	->	proof = g*(a|b) % n
bob = b		->	proof = g*(a|b) % n
____________________________________________________
```
answer: using "ratchet - hash(a)" solution and in/on hashed conversation.
- n = random number
- g = generator area (where code publicly run, and "n" somewhere in the edge of this area)
- "n" position into "g" is LFSR driven (random initial state, unlimited chance to generate random by hirarchical shifting to the right and replace to the left by using xor pattern)
- LFSR presentation code in the end of this document
```
________________________________
| n1        | n3               |
________________________________
|       n4      |   n2         |
________________________________
```
this conversation/convensition not like [SchrÃ¶dinger's cat](https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat) , and answer is O(1)=1 try.

---

### I found this two good examples for LFSR around the web

#### LFSR presentation
```py
state = 0b1001
for i in range(15):
	print("{:04b}".format(state))
	newbit = (state ^ (state >> 1)) & 1
	state = (state >> 1) | (newbit << 3)
```

#### huge amount of random number
```py
##state = 0b1001
state =  (1 << 127) | 1
while true:
	print(state & 1, end = ' ')
	newbit = (state ^ (state >> 1) ^ (state >> 2) ^ (state >> 7)) & 1
	state = (state >> 1) | (newbit << 127)

## this code made random number. by the power of my cpu  maybe 39billion years for finish randoms !!!
## this LFSR python codes generated by @Computerphile, to present LFSR
```
For safe generating the random number by a hardware, you can use "Atari" transistor. so cheap and useful. problem is: each second just 1 random number processing!

---

#### Problem of sense data solved by using erlang
#erlang for sensetive transaction have the better performance...
